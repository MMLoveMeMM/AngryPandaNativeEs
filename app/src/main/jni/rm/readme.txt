这个文档增加一些接口,原理等说明:
%---------------------------------------------------------------------------------------------------%
参考 : http://www.jianshu.com/p/dfe29d697a62
通过顶点缓冲对象(Vertex Buffer Objects, VBO)管理这个内存，它会在GPU内存(通常被称为显存)中储存大批顶点。
使用这些缓冲对象的好处是我们可以一次性的发送一大批数据到显卡上，而不是每个顶点发送一次。

就像OpenGL中的其他对象一样，这个缓冲有一个独一无二的ID，所以我们可以使用glGenBuffers函数生成一个缓冲ID：

GLuint VBO;
glGenBuffers(1, &VBO);
OpenGL有很多缓冲对象类型，GL_ARRAY_BUFFER是其中一个顶点缓冲对象的缓冲类型。OpenGL允许我们同时绑定多个缓冲，
只要它们是不同的缓冲类型。我们可以使用glBindBuffer函数把新创建的缓冲绑定到GL_ARRAY_BUFFER上：

glBindBuffer(GL_ARRAY_BUFFER, VBO);
从这一刻起，我们使用的任何缓冲函数(在GL_ARRAY_BUFFER目标上)都会用来配置当前绑定的缓冲(VBO)。然后我们可以调用glBufferData函数，
它会把之前定义的顶点数据复制到缓冲的内存中：

glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
glBufferData是一个用来把用户定的义数据复制到当前绑定缓冲的函数。它的第一个参数是我们希望把数据复制到上面的缓冲类型：
顶点缓冲对象当前绑定到GL_ARRAY_BUFFER目标上。第二个参数指定我们希望传递给缓冲的数据的大小(以字节为单位)；
用一个简单的sizeof计算出顶点数据就行。第三个参数是我们希望发送的真实数据（的指针）。

第四个参数指定了我们希望显卡如何管理给定的数据。有三种形式：

GL_STATIC_DRAW ：数据不会或几乎不会改变。
GL_DYNAMIC_DRAW：数据会被改变很多。
GL_STREAM_DRAW ：数据每次绘制时都会改变。
三角形的位置数据不会改变，每次渲染调用时都保持原样，所以它使用的类型最好是GL_STATIC_DRAW。如果，
比如，一个缓冲中的数据将频繁被改变，那么使用的类型就是GL_DYNAMIC_DRAW或GL_STREAM_DRAW。这样就能确保图形卡把数据放在高速写入的内存部分。

到现在我们已经把顶点数据储存在显卡的内存中，并且用VBO顶点缓冲对象来管理。下面我们会创建一个顶点和片段着色器，来处理这些数据
%---------------------------------------------------------------------------------------------------%









